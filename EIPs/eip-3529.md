# # EIP-3529: Reduction in refunds

DATE: April 26, 2024

AUTHOR: Seunghyun Cho(@c0np4nn4)


## 요약
`SELFDESTRUCT` 에서 *가스 환불* 을 제거하고 `SSTORE` 에서는 *가스 환불* 정도를 낮춤으로써, “exploit” 이 가능한 현재의 환불 정책을 수정합니다.

## EIP 제안 동기
`SELFDESTRUCT` 와 `SSTORE` 에 *가스 환불* 이 제안된 최초의 동기는 어플리케이션 개발자들이 “깔끔한 상태”의 어플리케이션을 작성하도록 동기를 부여하기 위해서였습니다. 
여기서 “깔끔한 상태”란 <u>더 이상 필요없는</u> 저장소 슬롯과 컨트랙트를 비우는 것을 말합니다.
하지만, 이러한 방법은 기대보다 훨씬 낮은 결과와 심지어 의도되지 않은 결과들을 낳았습니다.
- *가스 환불* 로 인해 **GasToken** 전략이 등장합니다.
  - `GasToken`은 낮은 수수료 기간에 가스를 구매하여 높은 수수료 기간에 사용함으로써 전체적인 트랜잭션 비용을 절감하는 메커니즘을 제공합니다. 
  마치 `가스 저장 배터리`처럼 작동한다고 알려져있습니다.
  - 그러나 `GasToken`을 저장하기 위해 **상태 데이터**가 필요하게 됩니다.
  이는 전체 네트워크의 상태 크기가 커지는 문제로 이어집니다.
  또한, `GasToken`의 생성과 소멸 과정에서 상당량의 가스가 소모되어 **네트워크의 전체적인 가스 사용 효율이 저하됩니다**.
  이러한 문제들은 결국 전체적인 네트워크 성능에 부정적인 영향을 미칩니다.
- *가스 환불* 은 블록 크기의 변동성을 증가시킵니다.
  - 이더리움 블록체인에서 각 트랜잭션은 특정 양의 가스를 소비합니다.
  *가스 환불* 은 소비된 가스를 최대 50%까지 다시 환불해줍니다. 
  또, 각 블록에 대해서도 처리할 수 있는 가스의 한도([30 million](https://ethereum.org/en/developers/docs/gas/#maxfee))가 정해져 있습니다. 
  - *가스 환불* 이 다음 트랜잭션에 추가적인 가스 공간(가스가 더 소비될 수 있는 가능성)을 제공하기 때문에, 이론적으로 한 블록에서 실제로 소비될 수 있는 가스의 양은 블록에 명시된 가스 한도의 거의 두 배에 이를 수 있습니다. 결과적으로, 한 블록 내에서 트랜잭션이 소비할 수 있는 가스의 양이 기대치보다 훨씬 높을 수 있으며, 이는 블록 크기의 변동성을 크게 증가시킵니다.
  - 이러한 변동성은 치명적이진 않습니다. 하지만, EIP-1559 가 도입되면서 블록당 가스 한도가 시장 매커니즘에 따라 동적으로 조정되는데, 환불을 통해 사용 가능한 가스가 증가하면 이로 인해 2배에 가까운 사용량 증가가 길게 유지될 수 있습니다. 따라서, EIP-1559의 도입 목적인 *블록 가스 사용의 더 정확한 조절과 예측 가능성 향상* 에 반하는 결과를 초래할 수도 있습니다. 이러한 문제는 네트워크 효율성과 안정성을 저하시킬 수 있습니다.

따라서,  `SSTORE` 와 `SELFDESTRUCT` EVM opcode 를 수정하여 이러한 *가스 환불* 에 관한 문제들을 해결하고자 합니다.

## 선정 이유
이더리움을 공부하며 알게되는 *Gas*, *Refund* 와 같은 개념들을 이번 기회에 이해해보고자 합니다.
*Refund* 를 조정하게된 이유 및 어떤 효과를 기대할 수 있는지에 대해 살펴보고자 합니다. 

## 본론
`London hard fork` 에 해당하는 $12,965,000$ 번째 블록 이후부터 아래의 변화들이 적용됩니다.
1. `SELFDESTRUCT` 에 대한 **환불** 메커니즘이 제거
2. `SSTORE` 에 대한 **환불 값** 조정
- [EIP-2200](https://eips.ethereum.org/EIPS/eip-2200) 에서 정의된 `SSTORE_CLEARS_SCHEDULE` **환불 값** 을 아래와 같이 조정합니다.
<!-- `SSTORE_RESET_GAS - COLD_SLOAD_COST + ACCESS_LIST_STORAGE_KEY_COST` 로 변경합니다.  -->

$$
\begin{align}
  &\text{SstoreClearsSchedule} \newline
  &\text{SstoreResetGas} - \text{ColdSloadCost} + \text{AccessListStorageKeyCost} \newline
  &= 5,000 - 2,100 + 1,900 \newline
  &= 4,800
\end{align}
$$

조정된 값은 $4,800$ 이며 계산에 사용된 값은 각각 아래 EIP 들에서 적용되었습니다.

| EIP | Name | Gas |
|:---:|:---:|:---:|
|2200|`SSTORE_RESET_GAS`|$5,000$|
|2929|`COLD_SLOAD_COST`|$2,100$|
|2930|`ACCESS_LIST_STORAGE_KEY_COST`|$1,900$|


3. 트랜잭션 수행 후 환불되는 **최대 가스량** 조정
- **최대 환불 가스량**은 아래와 같습니다. *MaxRefundQuotient* 값을 $2$ 에서 $5$ 로 증가시킴으로써 환불되는 가스량을 감소시킵니다.

$$
\begin{align}
\text{MaxRefundGas} = \lfloor\frac{\text{GasUsed}}{\text{MaxRefundQuotient}}\rfloor
\end{align}
$$

### EIP-2200 에 관한 이해
우선 `EIP-2200` 은 아래 그림과 같이 `SSTORE`에 대한 *Gas* 비용 및 환불 정도를 
세 종류로 세분화한 EIP 입니다.

<img src="https://github.com/c0np4nn4/c0np4nn4.github.io/assets/49471288/00e1b27d-6f6d-4585-9f8e-76db2b4cf3af"/>

- `SSTORE_SET_GAS`($20,000$)
    - 새로운 값을 저장할 때 드는 **가스량** 입니다.
- `SSTORE_RESET_GAS`($5,000$)
    - 기존 값을 새로운 값으로 재설정할 때 드는 **가스량** 입니다.
- `SSTORE_CLEARS_SCHEDULE`($15,000$)
    - 기존 값을 제거하고 비우는 데 드는 **가스량** 입니다.

상기한 세 종류의 값을 **변수**에 저장하고, 이를 활용해 *비용* 과 *환불* 을 계산합니다.

### 환불 조정에 관한 근거
[EIP-2200](https://eips.ethereum.org/EIPS/eip-2200#specification) 에서 아래 세 경우의 **환불**이 제안되었습니다.

1. `기존의 값`이 $0$이 아니고 `새로운 값`이 $0$일 경우
   - `SSTORE_CLEARS_SCHEDULE` 가스 값(현재 $15,000$) 을 *refund counter* 에 더합니다.
2. `기존의 값`이 $0$이고 `현재의 값`이 $0$이 아닐 때, 그리고 `새로운 값`이 $0$인 경우
   - `SSTORE_SET_GAS - SLOAD_GAS` 가스 값(현재 $19,900$) 을 *refund counter* 에 더합니다.
3. `기존의 값`이 $0$이 아니고 `현재의 값`이 `기존의 값`과 다른 $0$이 아닌 값일 때, 그리고 `새로운 값`이 `기존의 값`과 동일한 경우
   - `SSTORE_RESET_GAS - SLOAD_GAS` 가스 값(현재 $4,900$) 을 *refund counter* 에 더합니다.

여기서 ‘기존의 값’, ‘현재 값’, ‘새로운 값’은 [EIP-2200](https://eips.ethereum.org/EIPS/eip-2200#motivation)의 맥락에서 사용된 단어이며, 스토리지 슬롯의 값을 의미합니다. 스토리지의 슬롯 값이 비어있으면($0$ 인 경우) 가스 환불을 받을 수 있습니다.

우선 (2), (3) 경우에 대해 살펴보고 (1)에 대해 살펴보도록 하겠습니다.

#### (2) 0 -> ~0 -> 0
이더리움에서 스토리지를 사용할 때, 스토리지 슬롯에 데이터를 설정하거나 변경하는 데는 가스가 소비됩니다. 특히, 특정 스토리지 슬롯의 값이 $0$에서 $0$이 아닌 값으로 변경될 때는 일반적으로 높은 가스 비용이 듭니다. 즉, `SSTORE_SET_GAS` (=$20,000$) 라는 가스 비용이 부과됩니다.

(2)의 경우는 스토리지 슬롯이 처음에 비어있다가 트랜잭션 실행 과정 중 슬롯에 데이터를 저장하게 되고, 트랜잭션이 완료된 후에는 다시 슬롯을 비우는 상황입니다.

따라서, 스토리지 슬롯을 처음에 $0$ 에서 변경하면 약 $20,000$ 가스가 소비됩니다. 그리고 나중에 이 값을 다시 $0$으로 되돌리면, `SSTORE_SET_GAS - SLOAD_GAS` (=$19,900$) 만큼의 가스를 환불 받을 수 있습니다.

이 과정에서 환불받는 가스량이 처음에 소비한 가스량과 거의 같고 오히려 적기 때문에 `GasToken` 을 사용할 수 없습니다. 
`GasToken` 은 지불한 가스보다 환불받을 수 있는 가스량이 상대적으로 높을 때 유용합니다. 따라서, (2)의 경우는 큰 문제가 되지 않습니다.

#### (3) ~0 -> ~0’ -> ~0
스토리지 슬롯에 대한 ‘재설정’ 작업은 `SSTORE_RESET_GAS` 만큼의 비용이 부과됩니다. 
트랜잭션 수행 완료 후 처음의 상태로 되돌아 온 경우 `SSTORE_RESET_GAS - SLOAD_GAS` ($=4,900$) 만큼의 가스를 환불받을 수 있습니다. 
따라서, (2) 와 비슷한 이유로 큰 문제가 되지 않습니다.

#### (1) ~0 -> 0
`EIP-3529`는 `(1)` 경우에 발생할 수 있는 **GasToken** 을 대비하기 위해 제안되었다고 볼 수 있습니다.

여기서 **Pairing** 의 개념을 활용할 수 있습니다. 
이는 어떤 **환불** 에 대해 *같은 Tx 에서 같은 slot 에 대해 발생했던* 바로 이전의 **비용** 을 연결짓는 것입니다.
`(1)`에서의 상황은 스토리지 슬롯이 $0$ 이 아니다가 $0$이 된 상황을 의미합니다.
이 경우, 두 가지 가능성을 생각해볼 수 있습니다.

1. 처음으로 스토리지 슬롯이 $0$ 이 되는 경우
   - 이 상황에서 발생하는 **환불**은 아래 **비용**과 연결됩니다.
       - 직전에 스토리지 슬롯을 <u>읽고</u> <u>수정</u>하는데 드는 비용 
       - `ACCESS_LIST_STORAGE_KEY_COST` + `SSTORE_RESET_GAS` 
2. 두 번째 또는 그 이후에 스토리지 슬롯이 $0$ 이 되는 경우
    - 이 상황에서 발생하는 **환불**은 아래 **비용**과 연결됩니다.
        - 직전에 스토리지 슬롯을 <u>0 이 아닌 상태</u>로 변경하는데 드는 비용
            - 위 상황에서 스토리지 슬롯이 $0$이 되며 추가되었었던 *환불* 값은 사라지게 됩니다.
                
두 번째 경우는 *환불된 값만큼이 제거* 되기 때문에 `SSTORE_CLEARS_SCHEDULE` 의 값이 얼마인지는 중요하지 않습니다. 
따라서 지불되는 가스 **비용**을 양의 값으로 하고 싶다면,
첫 번째 경우의 **비용**이 **환불**되는 값보다 크거나 같도록 해야 합니다. 

$$
\begin{align}
\text{SstoreClearsSchedule} \le \text{SstoreResetGas} + \text{AccessListStorageKeyCost}
\end{align}
$$

### 이전 버전과의 호환성
**환불**은 트랜잭션의 수행이 끝난 후에만 적용되므로, 실행 중인 특정 *함수 호출 프레임* 내에서의 사용 가능한 가스 양에 영향을 미치지는 않습니다. 
따라서, **환불** 을 제거해도 코드 실행에는 영향을 주지 않습니다. 
댜만, 일부 어플리케이션은 *경제적 문제*가 발생할 수 있습니다.

EIP-3529 적용은 `GasToken`의 가치 하락으로 이어지게 됩니다. 
현재 많은 `DeFi 자동화 봇`들이 이미 설정된 `GasToken` 스킴이나 맞춤형 대안을 사용하여 온체인 비용을 줄이고 있지만, 수정이 필요할 것입니다.
하지만, **환불** 정책을 아예 제거하는 것은 아닙니다. 
몇 가지 주요 사례에서는 여전히 기존 방식대로 가스 비용 처리를 하게 됩니다. 
예를 들어, $0 \rightarrow \neg 0 \rightarrow 0$ 과 같은 패턴에서 여전히 가스는 최대 $100$만 소비됩니다. 
*몇 가지 주요 사례* 는 아래와 같습니다.

1. `Anti-Reentrancy Lock`
   - 자식 호출이 시작되기 전에 바로 $0 \rightarrow 1$ 로 상태가 전환됩니다.
   - 자식 호출이 종료되면 $1 \rightarrow 0$ 로 상태가 돌아옵니다.
   - 이렇게 잠금 상태를 변경함으로써, 재진입 공격을 방지할 수 있습니다.
   - **환불** 을 통해 가스 **비용**을 저렴하게 지불할 수 있습니다.
2. `ERC20 approve-and-send`
   - 사용자가 토큰을 전송하기 전에 먼저 해당 수량을 승인해야 합니다.
   - *승인된 값* 은 토큰 전송이 승인될 때 $0 \rightarrow \neg 0$로 변경됩니다.
   - 토큰 전송이 처리되면 다시 $\neg 0 \rightarrow 0$ 이 됩니다.
   - 이러한 메커니즘을 이용해 자신의 토큰을 안전하게 다른 주소로 옮길 수 있습니다.
   - 마찬가지로, **환불** 을 통해 가스 **비용**을 저렴하게 지불할 수 있습니다.

### 스토리지 clearing incentives 에 대한 영향
이전에도 **환불 제거**에 관한 EIP들은 제안되었습니다. 
예를 들어, [EIP-3298](https://eips.ethereum.org/EIPS/eip-3298)(2021년 2월), [EIP-3403](https://eips.ethereum.org/EIPS/eip-3403)(2021년 3월)가 있습니다.
두 EIP 모두 `SELFDESTRUCT`와 `SSTORE`에 관한 환불을 **제거**하거나 **조정**하기를 제안합니다.

하지만, 이 둘은 스토리지 값을 **0**으로 설정하는 유인을 완전히 제거합니다.
즉, 사용자가 해당 스토리지 슬롯을 다시 사용할 가능성이 조금이라도 있을 것으로 예상되는 경우 스토리지 슬롯을 완전히 지우지 않도록 유도합니다.

예를 들어, *ERC20* 토큰을 정확히 1개 보유하고 있다고 해보겠습니다.
이를 타인에게 양도하거나 매도하는 경우 $0.9999999$ 개만 전송하고 나머지는 남겨둘 수 있습니다.
소량의 토큰을 남겨 두는 이유는 아래와 같습니다.

| Case | OP code | Gas fee |
|:---:|---|---|
| *비어있는 슬롯에 데이터를 저장* | `COLD_SLOAD_COST`+ `SSTORE_SET_GAS` | $2,100 + 20,000 = 22,100$ |
| *슬롯의 값을 수정* | `SSTORE_RESET_GAS`| $5,000$ |

즉, **수정**하는게 훨씬 저렴하기 때문입니다.
**환불**이 존재할 때는 이러한 불균형을 `EIP-2200`에서의 `SSTORE_CLEARS_SCHEDULE` 만큼의 값 ($15,000$) 으로 어느 정도 상쇄할 수 있습니다.

**EIP-3529**에서는 $4,800$ 만큼의 **환불**을 가능하게 합니다.
물론 이 수치는 아주 이상적이진 않지만, 일반적인 사람들에게 *스토리지 슬롯을 비우도록* 하는 요인으로는 작용할 수 있습니다.

**환불**을 소비된 가스의 1/5로 제한하는 것은 이 **환불**을 블록을 처리하는 데 필요한 스토리지 쓰기 작업의 양을 최대 25%까지만 증가시키는 데 사용할 수 있다는 의미입니다.
스토리지 쓰기 중심의 서비스 거부 공격(*DDoS*)에 이 메커니즘을 사용하는 것이 제한됩니다.

## Test Cases
[[EIP-3529, Test Cases](https://eips.ethereum.org/EIPS/eip-3529#test-cases)] 를 참고할 수 있습니다.

## Security Considerations
**환불**은 *Tx* 실행 단계에서는 표시되지 않습니다.
그러므로, *Tx 실행 로직* 에는 아무런 영향을 주지 않습니다.

*한 블록 내에서 지불될 수 있는 가스의 최대량* 은 `SSTORE`로 스토리지 슬롯에 값을 **저장**한 뒤 **리셋**되는 경우를 고려하지 않으면, 
명시된 *Gas Limit* 으로 제한됩니다.

이러한 `SSTORE`가 **Reset**되면 저장소가 확장되지 않고 클라이언트가 실제로 Merke 트리를 조정할 필요가 없으므로,
가스 소비량은 환불되지만 해당 옵코드를 처리하는 데 일반적으로 필요한 노력도 취소됩니다.
따라서, 이를 고려하지 않아도 괜찮습니다.

스토리지에 "쓰기"되는 데이터가 `new_value = original_value` 라면 수행되지 않도록 해야 합니다.
이는 이더리움의 초창기부터 신중하게 최적화되었지만 지금은 더 중요해졌습니다.

 

## Conclusion
`EIP-3529`는 이더리움의 *가스 환급 메커니즘*을 변경합니다.
특히 `SSTORE` 작업에 대한 환급을 줄이는 것을 제안하여, `GasToken`의 문제점을 해소하고 블록체인의 효율성을 높이기 위해 제안되었습니다.
또한, `EIP-3529`에서 언급하는 *스토리지 슬롯*, *가스 비용*, *환급* 등을 이해하는 데에는
앞서 제안된 *EIP-2200*, *EIP-2929*, *EIP-3298* 등을 이해하면 좋습니다.

---
## Reference
https://eips.ethereum.org/EIPS/eip-3529

https://eips.ethereum.org/EIPS/eip-2929

https://github.com/orakle-opensource/EIP_opensource/blob/9825f6a05d5cf0348a1c14b2c733fa7fbf6c9bc9/EIPs/eip-2929.md

https://ethereum.org/en/history/#london

https://hackmd.io/@fvictorio/gas-costs-after-berlin

https://www.evm.codes/#54?fork=cancun

https://ethereum.org/en/developers/docs/gas/#maxfee
