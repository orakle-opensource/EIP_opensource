# EIP-100: Change difficulty adjustment to target mean block time including uncles


## Abstract
이 문서는 엉클 블록(uncle block) 마이닝 전략을 고려한 난이도 조정 알고리즘 수정 제안인 EIP-100을 분석합니다. 최근 작업 증명(PoW) 난이도 조정 알고리즘에 대한 관심이 증가함에 따라, 난이도 조정을 제안한 EIP-2에 이어 난이도 조정 알고리즘을 개선하는 EIP-100을 분석하게 되었습니다.

## Motivation

엉클블록(uncle block)은 블록의 유효성은 통과되었지만 최종 블록으로 인정받지 못한 블록들을 의미합니다. 2016년 4월 의도적으로 엉클 블록을 채굴하는 채굴 전략이 발견되었습니다.  엉클 마이닝 전략은 자신의 블록을 엉클 보상을 얻기 위해 자신의 블록을 삼촌(최고의 체인에 속하지 않는 블록)으로 강제하는 동시에 블록이 블록 난이도 조정에 기여하는 것을 방지하는 것으로 구성됩니다. 이는 보안 취약점이 아닙니다. 그러나 이는 불공정한 이점, 설계 결함 및 네트워크 안정성에 대한 위험으로 볼 수 있습니다. 

채굴 전략은 단순히 가장 긴 체인을 확장하는 블록 대신 엉클 블록을 채굴하는 것입니다. 엉클 블록만 채굴하려면 채굴자는 자신이 해결하는 블록이 가장 긴 체인(가장 가중치가 높은 체인)에 포함되지 않도록 해야 합니다. 예를 들어, 마이너는 일반 자식을 채굴하기 시작하지만 모든 피어가 다른 적법한 블록(동일한 높이)을 받을 때까지 기다렸다가 엉클 블록을 브로드캐스팅 합니다.  

##### 엉클 마이닝 알고리즘
```
1. B를 최고의 체인 팁으로 설정합니다("팁"은 체인에 마지막으로 추가된 블록임)
2. 블록 C 채굴을 시작하고 C는 B의 자식입니다.
3. 블록 C에 대한 솔루션이 발견되면 하위 C를 저장합니다 (그러나 브로드 캐스트하지 않음).
4. 대부분의 동료가 C의 블록 높이에서 C와 다른 블록을 가지고있는 경우 :
      1. 저장된 모든 하위 블록 검색 및 브로드캐스트
      2. 1단계로 이동
5. 3단계로 이동합니다
```

<p align="center">
  <img src="image.png" alt="엉클 마이닝 알고리즘" width="50%">
</p>

<p align="center">엉클 마이닝 알고리즘</p>

엉클 마이닝 알고리즘을 분석한 이론적 결과는 특정 최적 조건에서 광부의 해시 파워가 12.5% 이상일 때 엉클 마이닝이 수익성이 있음을 보여주며, 2016년 이더리움의 환경을 기준으로 임계치는 20%-37% 범위(장기적인 영향을 고려하지 않고)에 있다고 추정되었습니다.

이 문제의 원인은 다음과 같습니다. 

난이도를 계산하는 데 사용되는 이 당시의 이더리움 알고리즘은 상위 블록 시간만을 기반으로 한다는 점입니다. 기본적으로 부모 블록이 너무 가까우면 작은 단계로 난이도가 증가하고 너무 멀면 난이도가 감소합니다. 엉클 블록에 따른 체인 무게는 고려하지 않습니다. 반대로, 비트코인 난이도 조정 알고리즘은 마지막 2016개 블록을 가져와 난이도를 조정하여 첫 번째 및 마지막 블록 타임스탬프를 사용하여 평균 14일 만에 다음 2016개 블록이 생성되도록 합니다(그러나 미묘한 버그도 있음). 만약 이더리움이 비트코인과 비슷하지만 체인 가중치(무게/시간)를 기반으로 하는 알고리즘을 사용했다면, 엉클 채굴은 최고의 체인의 속도를 높이지 않았을 것이고, 엉클 마이닝은 방지되었을 것입니다.

따라서 이러한 문제를 해결하기 위해서 EIP-100 이 제안되었습니다.

## Change

현재 블록의 난이도를 계산하는 공식은 다음과 같습니다.

$$
\text{block.diff} = \text{parent.diff} + \frac{\text{parent.diff}}{2048} \times \max\left(1 - \frac{\text{block.timestamp} - \text{parent.timestamp}}{10}, -99\right) + \text{int}\left(2^{\left(\frac{\text{block.number}}{100000} - 2\right)}\right)
$$

을 다음과 같이 변경합니다.

$$
\text{block.diff} = \text{parent.diff} + \frac{\text{parent.diff}}{2048} \times \max\left(\begin{cases} 
2 & \text{if len(parent.uncles)} \\ 1 & \text{otherwise}
\end{cases}- \frac{{\text{timestamp} - \text{parent.timestamp}}}{9}, -99 \right) + \text{int}\left(2^{\left(\frac{\text{block.number}}{100000} - 2\right)}\right)
$$

#### Code 

```go
// MakeDifficultyCalculatorU256 creates a difficultyCalculator with the given bomb-delay.
// the difficulty is calculated with Byzantium rules, which differs from Homestead in
// how uncles affect the calculation
func MakeDifficultyCalculatorU256(bombDelay *big.Int) func(time uint64, parent *types.Header) *big.Int {
	// Note, the calculations below looks at the parent number, which is 1 below
	// the block number. Thus we remove one from the delay given
	bombDelayFromParent := bombDelay.Uint64() - 1
	return func(time uint64, parent *types.Header) *big.Int {
		/*
			https://github.com/ethereum/EIPs/issues/100
			pDiff = parent.difficulty
			BLOCK_DIFF_FACTOR = 9
			a = pDiff + (pDiff // BLOCK_DIFF_FACTOR) * adj_factor
			b = min(parent.difficulty, MIN_DIFF)
			child_diff = max(a,b )
		*/
		x := (time - parent.Time) / 9 // (block_timestamp - parent_timestamp) // 9
		c := uint64(1)                // if parent.unclehash == emptyUncleHashHash
		if parent.UncleHash != types.EmptyUncleHash {
			c = 2
		}
		xNeg := x >= c
		if xNeg {
			// x is now _negative_ adjustment factor
			x = x - c // - ( (t-p)/p -( 2 or 1) )
		} else {
			x = c - x // (2 or 1) - (t-p)/9
		}
		if x > 99 {
			x = 99 // max(x, 99)
		}
		// parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))
		y := new(uint256.Int)
		y.SetFromBig(parent.Difficulty)    // y: p_diff
		pDiff := y.Clone()                 // pdiff: p_diff
		z := new(uint256.Int).SetUint64(x) //z : +-adj_factor (either pos or negative)
		y.Rsh(y, difficultyBoundDivisor)   // y: p__diff / 2048
		z.Mul(y, z)                        // z: (p_diff / 2048 ) * (+- adj_factor)

		if xNeg {
			y.Sub(pDiff, z) // y: parent_diff + parent_diff/2048 * adjustment_factor
		} else {
			y.Add(pDiff, z) // y: parent_diff + parent_diff/2048 * adjustment_factor
		}
		// minimum difficulty can ever be (before exponential factor)
		if y.LtUint64(minimumDifficulty) {
			y.SetUint64(minimumDifficulty)
		}
		// calculate a fake block number for the ice-age delay
		// Specification: https://eips.ethereum.org/EIPS/eip-1234
		var pNum = parent.Number.Uint64()
		if pNum >= bombDelayFromParent {
			if fakeBlockNumber := pNum - bombDelayFromParent; fakeBlockNumber >= 2*expDiffPeriodUint {
				z.SetOne()
				z.Lsh(z, uint(fakeBlockNumber/expDiffPeriodUint-2))
				y.Add(z, y)
			}
		}
		return y.ToBig()
	}
}

```

이 새로운 공식은 엉클을 포함한 블록의 평균 생성 비율을 일정하게 유지하고, 이로 인해 상향 조작할 수 없는 매우 예측 가능한 발행 비율이 보장됩니다. 이 공식은 포함된 엉클 블록의 수를 고려합니다:

$$
\max\left(1 + \text{len(parent.uncles)} - \left(\frac{{\text{timestamp} - \text{parent.timestamp}}} {9}\right), -99\right)
$$


이것은 k개의 삼촌을 포함한 블록이 정확히 같은 타임스탬프를 가진 k+1개의 블록 집합과 동등하다고 가정하는 것과 거의 동일하다는 것을 수학적으로 쉽게 확인할 수 있습니다. 정확한 엉클 블록의 타임스탬프 값을 활용할 경우 블록 헤더만이 아닌 블록 전체에 의존해야 하는 문제가 발생합니다. 따라서 우리는 대신 블록 헤더에만 의존하여 근사치를 추정하는 위 공식을 사용합니다.

분모를 10에서 9로 변경함으로써 블록 시간이 대략적으로 유지되도록 보장됩니다.

## Reference
https://eips.ethereum.org/EIPS/eip-100

https://bitslog.com/2016/04/28/uncle-mining-an-ethereum-consensus-protocol-flaw/

